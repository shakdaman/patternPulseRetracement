//@version=6
indicator("Pattern Pulse Swiss Army Knife", shorttitle="PatternPulse SwissArmyKnife", overlay=true)

// --- GLOBAL TOGGLES ---
g_show_mas = input.bool(true, title="Moving Averages", group="Global Visibility", inline="g1")
g_show_bb = input.bool(true, title="Bollinger Bands", group="Global Visibility", inline="g1")
g_show_current_opens = input.bool(true, title="Current Period Opens", group="Global Visibility", inline="g2")
g_show_orb = input.bool(true, title="Opening Range Breakout", group="Global Visibility", inline="g2")
g_show_data_table = input.bool(true, title="ATR/RSI Table", group="Global Visibility", inline="g3")
g_show_tf_continuity = input.bool(true, title="Timeframe Continuity", group="Global Visibility", inline="g3")
g_use_weighted_scoring = input.bool(true, title="Weighted Scoring", group="Global Visibility", inline="g3", tooltip="Use Fibonacci-weighted scoring for higher timeframes")
g_show_broadening = input.bool(true, title="Broadening Formations", group="Global Visibility", inline="g4")
g_show_atr_rays = input.bool(true, title="ATR Rays", group="Global Visibility", inline="g4")


// --- HELPER FUNCTION FOR LINE STYLES (Used for drawn lines) ---
f_getLineStyle(style_string) =>
    style_string == "Solid" ? line.style_solid : style_string == "Dotted" ? line.style_dotted : line.style_dashed

// --- BROADENING FORMATION SETTINGS ---
bf_group = "Broadening Formation Settings"
bf_pivot_left = input.int(5, "Pivot Left Bars", group=bf_group, tooltip="Number of bars to the left to look for a pivot high/low.")
bf_pivot_right = input.int(5, "Pivot Right Bars", group=bf_group, tooltip="Number of bars to the right for a pivot to be confirmed.")
bf_upper_color = input.color(color.new(color.yellow, 0), "Upper Line Color", group=bf_group, inline="bf_upper")
bf_upper_width = input.int(1, "Width", minval=1, group=bf_group, inline="bf_upper")
bf_upper_style_str = input.string("Dotted", "Style", options=["Solid", "Dotted", "Dashed"], group=bf_group, inline="bf_upper")
bf_lower_color = input.color(color.new(color.yellow, 0), "Lower Line Color", group=bf_group, inline="bf_lower")
bf_lower_width = input.int(1, "Width", minval=1, group=bf_group, inline="bf_lower")
bf_lower_style_str = input.string("Dotted", "Style", options=["Solid", "Dotted", "Dashed"], group=bf_group, inline="bf_lower")


// --- MOVING AVERAGE SETTINGS ---
ma_group = "Moving Average Settings"
show_ema5 = input.bool(true, "EMA 5", group=ma_group, inline="ema5")
ema5_len = input.int(5, "Length", group=ma_group, inline="ema5")
ema5_color = input.color(color.new(color.green, 0), "Color", group=ma_group, inline="ema5_style")
ema5_width = input.int(1, "Width", minval=1, group=ma_group, inline="ema5_style")
ema5_style_str = input.string("Solid", "Style", options=["Solid", "Dashed"], group=ma_group, inline="ema5_style")
show_ema10 = input.bool(true, "EMA 10", group=ma_group, inline="ema10")
ema10_len = input.int(10, "Length", group=ma_group, inline="ema10")
ema10_color = input.color(color.new(color.red, 0), "Color", group=ma_group, inline="ema10_style")
ema10_width = input.int(1, "Width", minval=1, group=ma_group, inline="ema10_style")
ema10_style_str = input.string("Solid", "Style", options=["Solid", "Dashed"], group=ma_group, inline="ema10_style")
show_sma20 = input.bool(true, "SMA 20", group=ma_group, inline="sma20")
sma20_len = input.int(20, "Length", group=ma_group, inline="sma20")
sma20_color = input.color(color.new(color.green, 0), "Color", group=ma_group, inline="sma20_style")
sma20_width = input.int(2, "Width", minval=1, group=ma_group, inline="sma20_style")
sma20_style_str = input.string("Dashed", "Style", options=["Solid", "Dashed"], group=ma_group, inline="sma20_style")
show_sma200 = input.bool(true, "SMA 200", group=ma_group, inline="sma200")
sma200_len = input.int(200, "Length", group=ma_group, inline="sma200")
sma200_color = input.color(color.new(color.red, 0), "Color", group=ma_group, inline="sma200_style")
sma200_width = input.int(2, "Width", minval=1, group=ma_group, inline="sma200_style")
sma200_style_str = input.string("Dashed", "Style", options=["Solid", "Dashed"], group=ma_group, inline="sma200_style")

// --- BOLLINGER BANDS SETTINGS ---
bb_group = "Bollinger Bands Settings"
bb_len = input.int(20, "Length", group=bb_group, inline="bb_len")
bb_mult = input.float(2.0, "StdDev", group=bb_group, inline="bb_len")
bb_basis_color = input.color(color.new(color.teal, 50), "Basis Color", group=bb_group)
bb_upper_lower_color = input.color(color.new(color.teal, 50), "Bands Color", group=bb_group)
bb_fill_color = input.color(color.new(color.teal, 90), "Fill Color", group=bb_group)

// --- CURRENT PERIOD OPEN LINES SETTINGS ---
cpo_group = "Current Period Open Lines"
show_current_day_open = input.bool(true, "Current Day Open", group=cpo_group)
show_current_week_open = input.bool(true, "Current Week Open", group=cpo_group)
show_current_month_open = input.bool(true, "Current Month Open", group=cpo_group)
show_current_quarter_open = input.bool(true, "Current Quarter Open", group=cpo_group)
show_current_year_open = input.bool(true, "Current Year Open", group=cpo_group)
cpo_color = input.color(color.new(color.yellow, 0), "Line Color", group=cpo_group, inline="cpo_style")
cpo_width = input.int(1, "Width", minval=1, group=cpo_group, inline="cpo_style")
cpo_style_str = input.string("Solid", "Style", options=["Solid", "Dotted", "Dashed"], group=cpo_group, inline="cpo_style")
cpo_label_offset = input.int(20, "Label Offset", group=cpo_group, tooltip="Number of bars to offset the Current Period Open labels. Increase to move labels further right and prevent overlapping.")

// --- OPENING RANGE BREAKOUT (ORB) SETTINGS ---
orb_group = "Opening Range Breakout (ORB)"
orb_session = input.session("0930-1600", "Trading Session", group=orb_group)
orb_period_minutes = input.int(30, "ORB Period (Minutes)", group=orb_group, minval=1)
orb_high_color = input.color(color.new(#D2691E, 20), "High Color", group=orb_group, inline="orb_high")
orb_low_color = input.color(color.new(#D2691E, 20), "Low Color", group=orb_group, inline="orb_low")
orb_fill_color = input.color(color.new(#D2691E, 80), "Fill Color", group=orb_group)
orb_width = input.int(2, "Line Width", minval=1, group=orb_group)
orb_label_offset = input.int(10, "Label Offset", group=orb_group, tooltip="Number of bars to offset the ORB labels. Increase to move labels further right and prevent overlapping.")


// --- DATA DISPLAY SETTINGS ---
data_group = "Data Display Settings"
atr_len = input.int(14, "ATR Length", group=data_group)
rsi_len = input.int(14, "RSI Length", group=data_group)

// --- ATR RAYS SETTINGS ---
atr_ray_group = "ATR Ray Settings"
show_live_atr = input.bool(false, "Live ATR", group=atr_ray_group, tooltip="Real-time ATR levels based on current bar's close + current ATR. Updates dynamically as price moves. Best for active trading and real-time analysis.")
live_atr_color = input.color(color.new(color.aqua, 20), "Color", group=atr_ray_group, inline="live_atr")
live_atr_style_str = input.string("Solid", "Style", options=["Solid", "Dotted", "Dashed"], group=atr_ray_group, inline="live_atr")
live_atr_width = input.int(1, "Width", minval=1, group=atr_ray_group, inline="live_atr")
show_static_atr = input.bool(true, "Static ATR", group=atr_ray_group, tooltip="Fixed ATR levels based on previous bar's close + previous ATR. Provides consistent reference points that don't change during the current bar. Best for planning and analysis.")
static_atr_color = input.color(color.new(color.yellow, 20), "Color", group=atr_ray_group, inline="static_atr")
static_atr_style_str = input.string("Solid", "Style", options=["Solid", "Dotted", "Dashed"], group=atr_ray_group, inline="static_atr")
static_atr_width = input.int(1, "Width", minval=1, group=atr_ray_group, inline="static_atr")
atr_label_offset = input.int(10, "Label Offset", group=atr_ray_group, tooltip="Number of bars to offset the ATR labels. Increase to move labels further right and prevent overlapping.")

// --- CALCULATIONS ---
ema5 = ta.ema(close, ema5_len)
ema10 = ta.ema(close, ema10_len)
sma20 = ta.sma(close, sma20_len)
sma200 = ta.sma(close, sma200_len)
bb_basis = ta.sma(close, bb_len)
bb_dev = bb_mult * ta.stdev(close, bb_len)
bb_upper = bb_basis + bb_dev
bb_lower = bb_basis - bb_dev
atr_val = ta.atr(atr_len)
rsi_val = ta.rsi(close, rsi_len)
// Current period opens - using lookahead_off to get current period open prices
current_day_open = request.security(syminfo.tickerid, "D", open, lookahead=barmerge.lookahead_off)
current_week_open = request.security(syminfo.tickerid, "W", open, lookahead=barmerge.lookahead_off)
current_month_open = request.security(syminfo.tickerid, "M", open, lookahead=barmerge.lookahead_off)
current_quarter_open = request.security(syminfo.tickerid, "3M", open, lookahead=barmerge.lookahead_off)
current_year_open = request.security(syminfo.tickerid, "12M", open, lookahead=barmerge.lookahead_off)

// --- BROADENING FORMATION CALCULATION ---
var line upperTrendLine = na
var line lowerTrendLine = na

// Store pivot points: [price, bar_index]
var float ph1_price = na, var int ph1_index = na
var float ph2_price = na, var int ph2_index = na
var float pl1_price = na, var int pl1_index = na
var float pl2_price = na, var int pl2_index = na

pivotHighVal = ta.pivothigh(high, bf_pivot_left, bf_pivot_right)
pivotLowVal = ta.pivotlow(low, bf_pivot_left, bf_pivot_right)

if g_show_broadening
    // A new pivot high is detected
    if not na(pivotHighVal)
        // Shift previous pivot high values
        ph2_price := ph1_price
        ph2_index := ph1_index
        // Assign new pivot high values
        ph1_price := pivotHighVal
        ph1_index := bar_index - bf_pivot_right
    
        // If we have two pivot highs, check for broadening condition
        if not na(ph2_price)
            line.delete(upperTrendLine[1]) // Always delete the old line when a new pivot is confirmed
            // Only draw the new line if it's a HIGHER high
            if ph1_price > ph2_price
                upperTrendLine := line.new(ph2_index, ph2_price, ph1_index, ph1_price, extend=extend.right, color=bf_upper_color, style=f_getLineStyle(bf_upper_style_str), width=bf_upper_width)

    // A new pivot low is detected
    if not na(pivotLowVal)
        // Shift previous pivot low values
        pl2_price := pl1_price
        pl2_index := pl1_index
        // Assign new pivot low values
        pl1_price := pivotLowVal
        pl1_index := bar_index - bf_pivot_right
    
        // If we have two pivot lows, check for broadening condition
        if not na(pl2_price)
            line.delete(lowerTrendLine[1]) // Always delete the old line when a new pivot is confirmed
            // Only draw the new line if it's a LOWER low
            if pl1_price < pl2_price
                lowerTrendLine := line.new(pl2_index, pl2_price, pl1_index, pl1_price, extend=extend.right, color=bf_lower_color, style=f_getLineStyle(bf_lower_style_str), width=bf_lower_width)
else
    line.delete(upperTrendLine), line.delete(lowerTrendLine)


// --- ORB CALCULATION [MULTI-TIMEFRAME] ---
var line orbHighLine = na
var line orbLowLine = na
var label orbHighLabel = na
var label orbLowLabel = na
var linefill orbFill = na

var float session_orb_high = na
var float session_orb_low = na

// Get 1-minute data arrays for the current chart bar. This is the key to multi-timeframe compatibility.
[time_1m, high_1m, low_1m] = request.security_lower_tf(syminfo.tickerid, "1", [time, high, low])

session_start_time = time("D", orb_session, syminfo.timezone)
is_new_session = session_start_time != session_start_time[1]
orb_end_time = session_start_time + orb_period_minutes * 60 * 1000

// Reset on a new session
if is_new_session
    session_orb_high := na
    session_orb_low := na
    line.delete(orbHighLine[1])
    line.delete(orbLowLine[1])
    label.delete(orbHighLabel[1])
    label.delete(orbLowLabel[1])
    linefill.delete(orbFill[1])

// Check if there is 1-minute data available for this bar
if array.size(time_1m) > 0
    // Loop through the 1-minute bars that make up the current chart bar
    for i = 0 to array.size(time_1m) - 1
        t = array.get(time_1m, i)
        h = array.get(high_1m, i)
        l = array.get(low_1m, i)

        // If this 1m bar is within the ORB formation period, update the session's ORB high and low
        if t >= session_start_time and t < orb_end_time
            session_orb_high := na(session_orb_high) ? h : math.max(h, session_orb_high)
            session_orb_low := na(session_orb_low) ? l : math.min(l, session_orb_low)

// Drawing Logic: Draw if enabled, in the session, and we have valid ORB levels
in_session_for_drawing = time >= session_start_time
if g_show_orb and in_session_for_drawing and not na(session_orb_high)
    line.delete(orbHighLine[1])
    line.delete(orbLowLine[1])
    label.delete(orbHighLabel[1])
    label.delete(orbLowLabel[1])
    linefill.delete(orbFill[1])

    orbHighLine := line.new(session_start_time, session_orb_high, time, session_orb_high, xloc=xloc.bar_time, extend=extend.right, color=orb_high_color, width=orb_width)
    orbLowLine := line.new(session_start_time, session_orb_low, time, session_orb_low, xloc=xloc.bar_time, extend=extend.right, color=orb_low_color, width=orb_width)
    orbFill := linefill.new(orbHighLine, orbLowLine, color=orb_fill_color)

    orb_label_offset_time = time + (time - time[1]) * orb_label_offset
    orbHighLabel := label.new(orb_label_offset_time, session_orb_high, "ORB High", xloc=xloc.bar_time, yloc=yloc.price, style=label.style_label_left, color=color.new(orb_high_color, 20), textcolor=color.white, size=size.small)
    orbLowLabel := label.new(orb_label_offset_time, session_orb_low, "ORB Low", xloc=xloc.bar_time, yloc=yloc.price, style=label.style_label_left, color=color.new(orb_low_color, 20), textcolor=color.white, size=size.small)

// --- PLOTTING ---
plot(ema5, "EMA 5", color=g_show_mas and show_ema5 ? ema5_color : na, linewidth=ema5_width, style=ema5_style_str == "Solid" ? plot.style_line : plot.style_linebr)
plot(ema10, "EMA 10", color=g_show_mas and show_ema10 ? ema10_color : na, linewidth=ema10_width, style=ema10_style_str == "Solid" ? plot.style_line : plot.style_linebr)
plot(sma20, "SMA 20", color=g_show_mas and show_sma20 ? sma20_color : na, linewidth=sma20_width, style=sma20_style_str == "Solid" ? plot.style_line : plot.style_linebr)
plot(sma200, "SMA 200", color=g_show_mas and show_sma200 ? sma200_color : na, linewidth=sma200_width, style=sma200_style_str == "Solid" ? plot.style_line : plot.style_linebr)
p_bb_basis = plot(bb_basis, "BB Basis", color=g_show_bb ? bb_basis_color : na)
p_bb_upper = plot(bb_upper, "BB Upper", color=g_show_bb ? bb_upper_lower_color : na)
p_bb_lower = plot(bb_lower, "BB Lower", color=g_show_bb ? bb_upper_lower_color : na)
fill(p_bb_upper, p_bb_lower, title="BB Fill", color=g_show_bb ? bb_fill_color : na)

// --- LINE & LABEL MANAGEMENT (for last bar items) ---
var line staticUpperAtrLine = na, var line staticLowerAtrLine = na, var label staticUpperAtrLabel = na, var label staticLowerAtrLabel = na
var line liveUpperAtrLine = na, var line liveLowerAtrLine = na, var label liveUpperAtrLabel = na, var label liveLowerAtrLabel = na
var line cdoLine = na, var label cdoLabel = na, var line cwoLine = na, var label cwoLabel = na, var line cmoLine = na, var label cmoLabel = na, var line cqoLine = na, var label cqoLabel = na, var line cyoLine = na, var label cyoLabel = na

if barstate.islast
    // Delete current period opens lines unconditionally (they're always redrawn)
    line.delete(cdoLine[1]), label.delete(cdoLabel[1]), line.delete(cwoLine[1]), label.delete(cwoLabel[1]), line.delete(cmoLine[1]), label.delete(cmoLabel[1]), line.delete(cqoLine[1]), label.delete(cqoLabel[1]), line.delete(cyoLine[1]), label.delete(cyoLabel[1])
    
    atr_label_offset_time = time + (time - time[1]) * atr_label_offset
    cpo_label_offset_time = time + (time - time[1]) * cpo_label_offset
    
    // --- Static ATR ---
    if g_show_atr_rays and show_static_atr
        // Delete old lines first
        line.delete(staticUpperAtrLine[1]), label.delete(staticUpperAtrLabel[1]), line.delete(staticLowerAtrLine[1]), label.delete(staticLowerAtrLabel[1])
        
        static_upper_level = close[1] + atr_val[1]
        static_lower_level = close[1] - atr_val[1]
        static_upper_label_text = "Static ATR: " + str.tostring(static_upper_level, format.mintick)
        static_lower_label_text = "Static ATR: " + str.tostring(static_lower_level, format.mintick)
        staticUpperAtrLine := line.new(time[1], static_upper_level, time, static_upper_level, xloc = xloc.bar_time, extend=extend.both, color=static_atr_color, style=f_getLineStyle(static_atr_style_str), width=static_atr_width)
        staticUpperAtrLabel := label.new(atr_label_offset_time, static_upper_level, static_upper_label_text, xloc=xloc.bar_time, yloc=yloc.above_center, style=label.style_label_down, color=color.new(static_atr_color, 20), textcolor=color.white, size=size.small)
        staticLowerAtrLine := line.new(time[1], static_lower_level, time, static_lower_level, xloc = xloc.bar_time, extend=extend.both, color=static_atr_color, style=f_getLineStyle(static_atr_style_str), width=static_atr_width)
        staticLowerAtrLabel := label.new(atr_label_offset_time, static_lower_level, static_lower_label_text, xloc=xloc.bar_time, yloc=yloc.above_center, style=label.style_label_down, color=color.new(static_atr_color, 20), textcolor=color.white, size=size.small)
    else
        // Delete lines when toggles are off
        line.delete(staticUpperAtrLine[1]), label.delete(staticUpperAtrLabel[1]), line.delete(staticLowerAtrLine[1]), label.delete(staticLowerAtrLabel[1])

    // --- Live ATR ---
    if g_show_atr_rays and show_live_atr
        // Delete old lines first
        line.delete(liveUpperAtrLine[1]), label.delete(liveUpperAtrLabel[1]), line.delete(liveLowerAtrLine[1]), label.delete(liveLowerAtrLabel[1])
        
        live_upper_level = close + atr_val
        live_lower_level = close - atr_val
        live_upper_label_text = "Live ATR: " + str.tostring(live_upper_level, format.mintick)
        live_lower_label_text = "Live ATR: " + str.tostring(live_lower_level, format.mintick)
        liveUpperAtrLine := line.new(time, live_upper_level, time + 1, live_upper_level, xloc = xloc.bar_time, extend=extend.both, color=live_atr_color, style=f_getLineStyle(live_atr_style_str), width=live_atr_width)
        liveUpperAtrLabel := label.new(atr_label_offset_time, live_upper_level, live_upper_label_text, xloc=xloc.bar_time, yloc=yloc.above_center, style=label.style_label_down, color=color.new(live_atr_color, 20), textcolor=color.white, size=size.small)
        liveLowerAtrLine := line.new(time, live_lower_level, time + 1, live_lower_level, xloc = xloc.bar_time, extend=extend.both, color=live_atr_color, style=f_getLineStyle(live_atr_style_str), width=live_atr_width)
        liveLowerAtrLabel := label.new(atr_label_offset_time, live_lower_level, live_lower_label_text, xloc=xloc.bar_time, yloc=yloc.above_center, style=label.style_label_down, color=color.new(live_atr_color, 20), textcolor=color.white, size=size.small)
    else
        // Delete lines when toggles are off
        line.delete(liveUpperAtrLine[1]), label.delete(liveUpperAtrLabel[1]), line.delete(liveLowerAtrLine[1]), label.delete(liveLowerAtrLabel[1])

    // --- Current Period Opens ---
    if g_show_current_opens
        if show_current_day_open
            cdoLine := line.new(time[1], current_day_open, time, current_day_open, xloc = xloc.bar_time, extend=extend.both, color=cpo_color, style=f_getLineStyle(cpo_style_str), width=cpo_width)
            cdoLabel := label.new(cpo_label_offset_time, current_day_open, "Current Day Open", xloc=xloc.bar_time, yloc=yloc.above_center, style=label.style_label_down, color=color.new(cpo_color, 20), textcolor=color.white, size=size.small)
        if show_current_week_open
            cwoLine := line.new(time[1], current_week_open, time, current_week_open, xloc = xloc.bar_time, extend=extend.both, color=cpo_color, style=f_getLineStyle(cpo_style_str), width=cpo_width)
            cwoLabel := label.new(cpo_label_offset_time, current_week_open, "Current Week Open", xloc=xloc.bar_time, yloc=yloc.above_center, style=label.style_label_down, color=color.new(cpo_color, 20), textcolor=color.white, size=size.small)
        if show_current_month_open
            cmoLine := line.new(time[1], current_month_open, time, current_month_open, xloc = xloc.bar_time, extend=extend.both, color=cpo_color, style=f_getLineStyle(cpo_style_str), width=cpo_width)
            cmoLabel := label.new(cpo_label_offset_time, current_month_open, "Current Month Open", xloc=xloc.bar_time, yloc=yloc.above_center, style=label.style_label_down, color=color.new(cpo_color, 20), textcolor=color.white, size=size.small)
        if show_current_quarter_open
            cqoLine := line.new(time[1], current_quarter_open, time, current_quarter_open, xloc = xloc.bar_time, extend=extend.both, color=cpo_color, style=f_getLineStyle(cpo_style_str), width=cpo_width)
            cqoLabel := label.new(cpo_label_offset_time, current_quarter_open, "Current Quarter Open", xloc=xloc.bar_time, yloc=yloc.above_center, style=label.style_label_down, color=color.new(cpo_color, 20), textcolor=color.white, size=size.small)
        if show_current_year_open
            cyoLine := line.new(time[1], current_year_open, time, current_year_open, xloc = xloc.bar_time, extend=extend.both, color=cpo_color, style=f_getLineStyle(cpo_style_str), width=cpo_width)
            cyoLabel := label.new(cpo_label_offset_time, current_year_open, "Current Year Open", xloc=xloc.bar_time, yloc=yloc.above_center, style=label.style_label_down, color=color.new(cpo_color, 20), textcolor=color.white, size=size.small)

// --- ON-SCREEN DATA DISPLAY TABLE ---
var table infoPanel = table.new(position.middle_left, 1, 2, bgcolor = color.new(color.gray, 80), border_width = 1)
if barstate.islast
    if g_show_data_table
        atrString = timeframe.period + " ATR = " + str.tostring(atr_val[1], format.mintick)
        rsiString = "RSI = " + str.tostring(rsi_val, "#.##")
        table.cell(infoPanel, 0, 0, atrString, text_color = color.white, text_size=size.normal)
        table.cell(infoPanel, 0, 1, rsiString, text_color = color.white, text_size=size.normal)
    else
        table.clear(infoPanel, 0, 0, 0, 1)

// --- MODERN TIMEFRAME CONTINUITY TRACKER ---
// Type definition for timeframe data
type TfData
    int candle_type
    bool is_bullish
    float close_price
    float open_price

// Candle classification types: 1=Inside, 2=Breaker, 3=Outside
f_classifyCandle(tf) =>
    // Use consistent HTF data retrieval - get completed bars only for consistency
    [tf_high, tf_low, tf_close, tf_open] = request.security(syminfo.tickerid, tf, [high, low, close, open], lookahead=barmerge.lookahead_off)
    [tf_high_prev, tf_low_prev] = request.security(syminfo.tickerid, tf, [high[1], low[1]], lookahead=barmerge.lookahead_off)
    
    // Inside candle: current high < previous high AND current low > previous low
    is_inside = tf_high < tf_high_prev and tf_low > tf_low_prev
    
    // Outside candle: current high > previous high AND current low < previous low  
    is_outside = tf_high > tf_high_prev and tf_low < tf_low_prev
    
    // Determine candle type and direction based on TheStrat methodology
    candle_type = is_inside ? 1 : is_outside ? 3 : 2
    
    // For Breaker candles: direction based on which previous level is broken
    is_bullish = candle_type == 2 ? (tf_high > tf_high_prev) : (tf_close > tf_open)
    
    TfData.new(candle_type, is_bullish, tf_close, tf_open)

// Calculate momentum score based on Enhanced TheStrat methodology with Fibonacci weighting
f_calculateMomentum(tf_data_array, use_weighting) =>
    total_points = 0.0
    max_points = 0.0
    
    // Fibonacci weighting: 5m:1, 15m:1, 1H:2, 4H:3, D:5, W:8, M:13, Q:21
    weights = array.from<float>(1.0, 1.0, 2.0, 3.0, 5.0, 8.0, 13.0, 21.0)
    
    for i = 0 to array.size(tf_data_array) - 1
        tf_data = array.get(tf_data_array, i)
        candle_type = tf_data.candle_type
        is_bullish = tf_data.is_bullish
        is_green = tf_data.close_price > tf_data.open_price
        
        // Get weight for this timeframe
        weight = use_weighting ? array.get(weights, i) : 1.0
        
        // Enhanced scoring system
        if candle_type == 2  // Breaker candle
            if is_bullish  // Breaker Up
                if is_green
                    total_points += 1.0 * weight  // Strong bullish: Breaker Up + Green
                else
                    total_points += 0.5 * weight  // Weak bullish: Breaker Up + Red
            else  // Breaker Down
                if is_green
                    total_points -= 0.5 * weight  // Weak bearish: Breaker Down + Green
                else
                    total_points -= 1.0 * weight  // Strong bearish: Breaker Down + Red
            max_points += weight
        else if candle_type == 3  // Outside candle
            total_points += (is_green ? 1.0 : -1.0) * weight  // Full points based on candle color
            max_points += weight
        else if candle_type == 1  // Inside candle
            max_points += weight
            // 0 points for inside candles
        
    momentum_percent = max_points > 0 ? (total_points / max_points) * 100 : 0
    [momentum_percent, total_points, max_points]

// Get momentum color based on enhanced percentage scoring
f_getMomentumColor(momentum_percent) =>
    if momentum_percent >= 75
        color.new(color.green, 0)  // Strong Bullish
    else if momentum_percent >= 50
        color.new(color.new(color.green, 20), 0)  // Moderate Bullish
    else if momentum_percent >= 25
        color.new(color.new(color.green, 40), 0)  // Weak Bullish
    else if momentum_percent > -25
        color.new(color.gray, 0)  // Neutral
    else if momentum_percent >= -50
        color.new(color.new(color.orange, 20), 0)  // Weak Bearish
    else if momentum_percent >= -75
        color.new(color.new(color.red, 20), 0)  // Moderate Bearish
    else
        color.new(color.red, 0)  // Strong Bearish

// Create momentum meter visual
f_createMomentumMeter(momentum_percent) =>
    filled_segments = math.round(math.abs(momentum_percent) / 10)
    meter_text = ""
    
    for i = 1 to 10
        if i <= filled_segments
            meter_text += "█"
        else
            meter_text += "░"
    
    meter_text

// Get symbol and label for candle type
f_getCandleDisplay(candle_type, is_bullish, is_green) =>
    symbol = candle_type == 1 ? "‖" : candle_type == 3 ? "〇" : (is_bullish ? "▲" : "▼")
    label = candle_type == 1 ? "Inside" : candle_type == 3 ? "Outside" : (is_bullish ? "Breaker Up" : "Breaker Down")
    [symbol, label]

// Main timeframe continuity display
var table ftfcPanel = table.new(position.bottom_right, 8, 3, bgcolor = color.new(color.black, 50), border_width = 1)
var table momentumPanel = table.new(position.top_right, 1, 2, bgcolor = color.new(color.black, 60), border_width = 1)

if barstate.islast
    if g_show_tf_continuity
        // Define timeframes using proper Pine Script v6 arrays
        timeframes = array.from<string>("5", "15", "60", "240", "D", "W", "M", "3M")
        timeframe_labels = array.from<string>("5m", "15m", "1H", "4H", "D", "W", "M", "Q")
        
        // Collect timeframe data using proper type declaration
        var tf_data_array = array.new<TfData>()
        array.clear(tf_data_array)
        
        for i = 0 to array.size(timeframes) - 1
            tf = array.get(timeframes, i)
            tf_classification = f_classifyCandle(tf)
            array.push(tf_data_array, tf_classification)
        
        // Calculate momentum
        [momentum_percent, total_points, max_points] = f_calculateMomentum(tf_data_array, g_use_weighted_scoring)
        
        // Create momentum meter
        momentum_meter = f_createMomentumMeter(momentum_percent)
        momentum_color = f_getMomentumColor(momentum_percent)
        
        // Display momentum panel
        table.cell(momentumPanel, 0, 0, "Momentum: " + str.tostring(momentum_percent, "#.#") + "%", text_color=color.white, bgcolor=momentum_color, text_size=size.normal)
        table.cell(momentumPanel, 0, 1, momentum_meter, text_color=momentum_color, text_size=size.normal)
        
        // Display timeframe continuity panel
        for i = 0 to array.size(timeframes) - 1
            tf_data = array.get(tf_data_array, i)
            candle_type = tf_data.candle_type
            is_bullish = tf_data.is_bullish
            
            is_green = tf_data.close_price > tf_data.open_price
            [symbol, label] = f_getCandleDisplay(candle_type, is_bullish, is_green)
            
            // Enhanced color logic based on candle type and color
            symbol_color = candle_type == 1 ? color.white : 
                          candle_type == 3 ? (is_green ? color.new(color.green, 0) : color.new(color.red, 0)) :
                          candle_type == 2 ? (is_bullish ? color.new(color.green, 0) : (is_green ? color.new(color.orange, 0) : color.new(color.red, 0))) :
                          color.white
            
            label_color = candle_type == 1 ? color.white : 
                         candle_type == 3 ? (is_green ? color.new(color.green, 0) : color.new(color.red, 0)) :
                         candle_type == 2 ? (is_bullish ? color.new(color.green, 0) : (is_green ? color.new(color.orange, 0) : color.new(color.red, 0))) :
                         color.white
            
            // Row 0: Symbols
            table.cell(ftfcPanel, i, 0, symbol, text_color=symbol_color, bgcolor=color.new(color.black, 50), width=4, text_size=size.large)
            
            // Row 1: Timeframe labels  
            table.cell(ftfcPanel, i, 1, array.get(timeframe_labels, i), text_color=color.white, bgcolor=color.new(color.black, 50), width=4, text_size=size.normal)
            
            // Row 2: Status labels
            table.cell(ftfcPanel, i, 2, label, text_color=label_color, bgcolor=color.new(color.black, 50), width=4, text_size=size.small)
    else
        table.clear(ftfcPanel, 0, 0, 7, 2)
        table.clear(momentumPanel, 0, 0, 0, 1)
